# -*- coding: utf-8 -*-
"""
Created on Tue Dec 11 12:20:50 2018

@author: Gaurav-PC
"""
#The pupose of this script is to generate the random weather for a toy simulationtaking into 
#account things like atmosphere, topography, geography, #oceanography, or similar) that evolves over time
#It takes 2 arguments - input file (geo tif) and output file location (containing the sample data)

#import necessary libraries
import random,sys,threading,shutil,glob2
from datetime import datetime
from osgeo import  gdal
from argparse import ArgumentParser

#This is the reference data taken from the information available from internet
#based on the australian weather conditions. For e.g. during the snowy weather,
#the temperature typically floats between -7 to -1.
weather_conditions = {"Sunny": {"temperature": (40, 10), "pressure": (1200, 700), "humidity": (70, 55)},
                      "Rain": {"temperature": (25, 15), "pressure": (1200, 700), "humidity": (70, 55)},
                      "Snow": {"temperature": (-1, -7), "pressure": (1200, 700), "humidity": (70, 55)}}

#defalut initialization for latitude and longitude for the geo tif file
minx_long,miny_lat,maxx_long,maxy_lat = [0.0 for _ in range(4)]

#This function generates the random combination of the weather attributes such as temperature( in degree C),
#pressure (in hPa), relative humidity (in %) for 'Sunny','Rainy' and 'Snowy' seasons. This function uses
#weather_conditions variable as reference defined above and returns a string of combination of weather attributes
#pipe separated.
def randomWeather():
    weather = random.choice(list(weather_conditions.keys()))
    condition = weather_conditions[weather]
    (tMax, tMin) = condition["temperature"]
    (pMax, pMin) = condition["pressure"]
    (hMax, hMin) = condition["humidity"]
    
    #generate weather combination randomly by using random library
    outWeather = "{}|{}|{}|{}".format(weather,str(random.randint(tMin, tMax)),str(round(random.uniform(pMin,pMax), 1)),str(random.randint(hMin, hMax)))
    return outWeather

#This function generates a random date between current year and past 2 years. It returns a string in the 
#%Y-%m-%dT%H:%M:%SZ format, for e.g. 2015-12-23T05:02:12Z
def randomDate():
    year = random.randint(datetime.now().year - 2, datetime.now().year)
    month = random.randint(1, 12)
    day = random.randint(1, 28)
    hr = random.randint(0,23)
    min = random.randint(0,59)
    sec = random.randint(0,59)
    randomDateTime = datetime(year, month, day,hr,min,sec)
    formatedTime = '{:%Y-%m-%dT%H:%M:%SZ}'.format(randomDateTime)
    return formatedTime

#This function generates a randomly selected station from the list of the stations defined below. It returns a string.
def randomStations():
    stations = ['Sydney','Perth','Adelaide','Canberra','Melbourne','Hobart','Darwin','Bendigo','Albany','Brisbane']
    return random.choice(stations)

#This function generates the random output data in form of a pipe delimited string. It calls the above functions
#such as randomStations, randomDate, randomWeather. It also randomly selects the latitute and longitude of the
#geo tif image based on the min and max values of the lat & long.
#It generates a pipe delimited string with the format - 'Location|latitude,longitude,elevation|LocalTime|Condition|Temperature|Pressure|Humidity
def generateRandomOutputData():
    out_data = "{}|{},{},{}|{}|{}".format(str(randomStations()),str(round(random.uniform(miny_lat,maxy_lat),2)),
                                str(round(random.uniform(minx_long,maxx_long),2)),
                                random.randint(1,50),
                                str(randomDate()),
                                str(randomWeather()) + '\n')
    return out_data

#This functions defines the actual work that a thread would be performing in multithreaded scenario.
#It takes an int arguments which becomes the part of intermediate file which each thread would be generating.
def threadWork(seq):
    
    #open file in write mode
    weatherFile = open("weather_data_"+seq+".txt" , "w")
    
    #write 5000 lines of weather data in the intermediate file
    for x in range(5000):
        weatherFile.write(generateRandomOutputData())
    
    #close the file
    weatherFile.close()
    return

#This function merges the intermediate files generated by each thread in the current directory. It takes
#the output file name which contains the merged data.
def mergeFiles(outfilename):
    
    #look for all .txt files generated by each thread
    filenames = glob2.glob('weather_data_*.txt')
    
    #open the output file in write binary mode and copy the contents of intermediate files.
    with open(outfilename, 'wb') as outfile:
        for f in filenames:
            print(f)
            with open(f,'rb') as fd:
                #shutil library for faster copying as compared to write method.
                shutil.copyfileobj(fd, outfile)
                
#This function assigns the latitude and longitude to the global variables based on the formula by reading
#a geo tif file. It also throws an exception and exits incase there is an issue in parsing the geo tif file.
#It uses gdal library to parse the input file.
def initialize(inpfile):
    try:
        #open the geo tif file
        ds = gdal.Open(str(inpfile))
        
        #identify the X and Y pixels of the image
        width = ds.RasterXSize
        height = ds.RasterYSize
        
        #generate a geo transform object
        gt = ds.GetGeoTransform()
    except Exception as e:
        #exits incase of any issue parsing the file
        print('Error while parsing input file')
        sys.exit()
    
    #assigns the min & max for lat & long global variables based on the formula. 
    global  minx_long   
    minx_long = gt[0]
    
    global miny_lat
    miny_lat = gt[3] + width*gt[4] + height*gt[5] 
    
    global maxx_long
    maxx_long = gt[0] + width*gt[1] + height*gt[2]
    
    global maxy_lat
    maxy_lat = gt[3] 
    
    print ("miny_lat -> "+ str(miny_lat))
    print ("maxy_lat -> "+ str(maxy_lat))
    print ("minx_long -> "+ str(minx_long))
    print ("maxx_long -> "+ str(maxx_long))

#This function starts 2 threads which write the weather data to the intermediate files.
#Currently there are 2 threads started however, the level of multihtreading can be increased based on the 
#number of cores of the machine.
def transform():
    t1 = threading.Thread(target = threadWork,args=('1',))
    t1.start()
    t2 = threading.Thread(target = threadWork,args=('2',))
    t2.start()
    
    #wait for both the threads to complete
    t1.join()
    t2.join()

#This is the main driver function of the script. It takes 2 mandatory arguments - input(geo tif) file and output file which contains
#the weather data. It also call the initialize, transform and merge functions to achieve the objective of this program.          
if __name__ == '__main__':  
    
    #Input agrs
    parser = ArgumentParser(usage='%(prog)s [options]')
    try:
        parser.add_argument("-i", "--inputfile", help="Path of input GeoTif file",action="store",  dest="inputfile", required=True) 
        parser.add_argument("-o", "--outputloc", help="Output Location",action="store",  dest="outputloc", required=True)
        inpArgs = parser.parse_args()
    except Exception as e:
        parser.print_help()
  
    inputfile=inpArgs.inputfile
    outputloc=inpArgs.outputloc
    print ('Geo Tif file provided : ',inputfile)
    print ('Output file location : ',outputloc)
        
    #Step1. intialize
    initialize(inputfile)
    
    #Step2. transform using multithreading
    transform()
    
    #Step3. merge the intermediate results of threads and generate a single output file.
    mergeFiles(str(outputloc))